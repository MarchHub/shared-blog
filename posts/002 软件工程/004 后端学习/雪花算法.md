# 雪花算法 Snowflake

生成一个UID,“分布式友好”.

## 主要思想

把64bit划分成4段,来分别存储不同的信息,最后合并起来成为UID(当然,其实也可以自己来对它进行一些优化,比如把工作ID变长,序列号变长等,在此还是先说最原本的雪花)

从最高位依次往下分别是——

- 符号位: 1 bit
- 时间戳偏移量: 41bits
- 工作机器ID: 10bits
- 序列号: 12bits

### 符号位

最高位在机器中为符号位,为了保证其均为正数,于是将最高位定为0

### 时间戳偏移量

表示了从一个自定义的 epoch 以来的毫秒数.
在41bits的情况下,可以表示 $2^{41}$ 毫秒的时间长度,大约是 69 年
这个epoch可以自定义,实际上就是时间的起点
~~如果想要这个算法持续时间长一点可以把时间戳偏移量占的bits多弄点~~

### 工作机器 ID

实际上不单纯是工作机器的不同,还可以可以针对不同的线程来做——即给不同的线程或工作机器分配不一致的ID就行.
在10bits的情况下,可以最多表示 $2^{10}=1024$ 个机器,如果不够的话再加

### 序列号

如果一个机器在一毫秒内需要生成多个ID,就占用这些bits来进行一个简单的自增(此时使用自增可以保证唯一性).

可以理解为同一时刻算法的“吞吐量”

那么 12bits 就是 $2^{12} = 4096$ 个ID

## 实现

只要对每一个工作机器分配好ID, 然后每一个时刻获得毫秒数, 最后进行一个位运算拼接(左移和按位或)即可